

### lock_guard 和 unique_lock
std::lock_guard是RAII模板类的简单实现，功能简单。
std::lock_guard 在构造函数中进行加锁，析构函数中进行解锁

类 unique_lock 是通用互斥包装器，允许延迟锁定、锁定的有时限尝试、递归锁定、所有权转移和与条件变量一同使用。
unique_lock比lock_guard使用更加灵活，功能更加强大

### 完美转发 std::forward()
当我们将一个右值引用传入函数时，他在实参中有了命名，所以继续往下传或者调用其他函数时，根据C++ 标准的定义，这个参数变成了一个左值。那么他永远不会调用接下来函数的右值版本，这可能在一些情况下造成拷贝。为了解决这个问题 C++ 11引入了完美转发，根据右值判断的推倒，调用forward 传出的值，若原来是一个右值，那么他转出来就是一个右值，否则为一个左值。
这样的处理就完美的转发了原有参数的左右值属性，不会造成一些不必要的拷贝。代码如下：
右值引用类型是独立于值的，一个右值引用参数作为函数的形参，在函数内部再转发该参数的时候它已经变成一个左值，并不是他原来的类型。

### 优雅断开和强制断开
Linux下tcp连接断开的时候调用close()函数，有优雅断开和强制断开两种方式
```C
#include <arpa/inet.h>

struct linger {
　　int l_onoff;
　　int l_linger;
};
```
三种断开方式：
1. l_onoff = 0; l_linger忽略
close()立刻返回，底层会将未发送完的数据发送完成后再释放资源，即优雅退出。

2. l_onoff != 0; l_linger = 0;
close()立刻返回，但不会发送未发送完成的数据，而是通过一个REST包强制的关闭socket描述符，即强制退出。

3. l_onoff != 0; l_linger > 0;
close()不会立刻返回，内核会延迟一段时间，这个时间就由l_linger的值来决定。如果超时时间到达之前，发送完未发送的数据(包括FIN包)并得到另一端的确认，close()会返回正确，socket描述符优雅性退出。否则，close()会直接返回错误值，未发送数据丢失，socket描述符被强制性退出。需要注意的时，如果socket描述符被设置为非堵塞型，则close()会直接返回值。