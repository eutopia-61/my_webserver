

### lock_guard 和 unique_lock
std::lock_guard是RAII模板类的简单实现，功能简单。
std::lock_guard 在构造函数中进行加锁，析构函数中进行解锁

类 unique_lock 是通用互斥包装器，允许延迟锁定、锁定的有时限尝试、递归锁定、所有权转移和与条件变量一同使用。
unique_lock比lock_guard使用更加灵活，功能更加强大

### 完美转发 std::forward()
当我们将一个右值引用传入函数时，他在实参中有了命名，所以继续往下传或者调用其他函数时，根据C++ 标准的定义，这个参数变成了一个左值。那么他永远不会调用接下来函数的右值版本，这可能在一些情况下造成拷贝。为了解决这个问题 C++ 11引入了完美转发，根据右值判断的推倒，调用forward 传出的值，若原来是一个右值，那么他转出来就是一个右值，否则为一个左值。
这样的处理就完美的转发了原有参数的左右值属性，不会造成一些不必要的拷贝。代码如下：
右值引用类型是独立于值的，一个右值引用参数作为函数的形参，在函数内部再转发该参数的时候它已经变成一个左值，并不是他原来的类型。

### 优雅断开和强制断开
Linux下tcp连接断开的时候调用close()函数，有优雅断开和强制断开两种方式
```C
#include <arpa/inet.h>

struct linger {
　　int l_onoff;
　　int l_linger;
};
```
三种断开方式：
1. l_onoff = 0; l_linger忽略
close()立刻返回，底层会将未发送完的数据发送完成后再释放资源，即优雅退出。

2. l_onoff != 0; l_linger = 0;
close()立刻返回，但不会发送未发送完成的数据，而是通过一个REST包强制的关闭socket描述符，即强制退出。

3. l_onoff != 0; l_linger > 0;
close()不会立刻返回，内核会延迟一段时间，这个时间就由l_linger的值来决定。如果超时时间到达之前，发送完未发送的数据(包括FIN包)并得到另一端的确认，close()会返回正确，socket描述符优雅性退出。否则，close()会直接返回错误值，未发送数据丢失，socket描述符被强制性退出。需要注意的时，如果socket描述符被设置为非堵塞型，则close()会直接返回值。

###  EPOll事件
EPOLLONESHOT事件
epoll模式中事件可能被触发多次，比如socket接收到数据交给一个线程处理数据，在数据没有处理完之前又有新数据达到触发了事件，另一个线程被激活获得该socket，从而产生多个线程操作同一socket，即使在ET模式下也有可能出现这种情况。采用EPOLLONETSHOT事件的文件描述符上的注册事件只触发一次，要想重新注册事件则需要调用epoll_ctl重置文件描述符上的事件，这样前面的socket就不会出现竞态
EPOLLRDHUP 事件，代表对端断开连接

EPOLLIN - 当关联的文件可以执行 read ()操作时。
EPOLLOUT - 当关联的文件可以执行 write ()操作时。
EPOLLRDHUP - (从 linux 2.6.17 开始)当socket关闭的时候，或者半关闭写段的(当使用边缘触发的时候，这个标识在写一些测试代码去检测关闭的时候特别好用)
EPOLLPRI - 当 read ()能够读取紧急数据的时候。
EPOLLERR - 当关联的文件发生错误的时候，epoll_wait() 总是会等待这个事件，并不是需要必须设置的标识。
EPOLLHUP - 当指定的文件描述符被挂起的时候。epoll_wait() 总是会等待这个事件，并不是需要必须设置的标识。当socket从某一个地方读取数据的时候(管道或者socket),这个事件只是标识出这个已经读取到最后了(EOF)。所有的有效数据已经被读取完毕了，之后任何的读取都会返回0(EOF)。
EPOLLET - 设置指定的文件描述符模式为边缘触发，默认的模式是水平触发。
EPOLLONESHOT - (从 linux 2.6.17 开始)设置指定文件描述符为单次模式。这意味着，在设置后只会有一次从epoll_wait() 中捕获到事件，之后你必须要重新调用 epoll_ctl() 重新设置


如果要把一个序列（sequence）拷贝到一个容器（container）中去，通常用std::copy算法，代码如下：
std::copy(start, end, std::back_inserter(container));
start和end是输入序列（假设有N个元素）的迭代器（iterator），container是一个容器，该容器的接口包含函数push_back。假设container开始是空的，那么copy完毕后它就包含N个元素，并且顺序与原来队列中的元素顺序一样。

bind绑定类成员函数时，第一个参数表示对象的成员函数的指针，第二个参数表示对象的地址，这是因为对象的成员函数需要有this指针。并且编译器不会将对象的成员函数隐式转换成函数指针，需要通过&手动转换


堆排序

一般用数组来表示堆，下标为 i 的结点的父结点下标为(i-1)/2；其左右子结点分别为 (2i + 1)、(2i + 2)

### bug

1、printf、cout输出到显缓中，加 \n
2、epoll 每处理完一次事件后，需要重新添加监听事件
3、段错误，一般是指针位置错误
